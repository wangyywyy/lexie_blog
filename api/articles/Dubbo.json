{"title":"Dubbo","slug":"Dubbo","date":"2021-03-27T14:28:00.482Z","updated":"2021-08-05T09:40:25.171Z","comments":true,"path":"api/articles/Dubbo.json","photos":[],"link":"","excerpt":null,"covers":["assets%5Cimage-20210106110638787.png","assets\\分布式服务架构.png","assets/SOA.png","assets%5Cimage-20210106144404533.png","assets\\aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNjAzNDI3OS03N2RiNDJkNjU0M2EwMzgzLnBuZw.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804151123294.png","assets\\aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNjAzNDI3OS01ZGZlMmMzNmJmM2NlOGYyLnBuZw.png","assets\\1583212844170830.png","assets\\01_dubbo的工作原理.png","assets\\822135-20190720224216104-761168332.jpg"],"content":"<h1 id=\"分布式系统\"><a href=\"#分布式系统\" class=\"headerlink\" title=\"分布式系统\"></a>分布式系统</h1><p>分布式系统：若干独立计算机的集合，这些计算机对于用户来说就像单个相关系统。</p>\n<p>基于服务的架构演变过程</p>\n<p><img src=\"assets%5Cimage-20210106110638787.png\" alt=\"image-20210106110638787\"></p>\n<ul>\n<li><p>单一应用架构</p>\n<p>将所有功能都部署在一起，以减少部署节点和成本，适用于小型管理系统。</p>\n<p>此时，用于简化增删改查工作量的数据访问框架(ORM)是关键。</p>\n<p>缺点： 性能扩展比较难，协同开发问题，不利于升级维护。</p>\n</li>\n<li><p>垂直应用架构</p>\n<p>通过切分业务来实现各个模块独立部署，降低了维护和部署的难度，团队各司其职更易管理，性能扩展也更方便，更有针对性。</p>\n<p>此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>\n<p>缺点： 公用模块无法重复利用，开发性的浪费</p>\n</li>\n<li><p>分布式服务架构</p>\n<p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。</p>\n<p>此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p>\n<img src=\"assets\\分布式服务架构.png\" style=\"zoom:50%;\" /></li>\n<li><p>流动计算架构</p>\n<p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现。业务资源池中每个业务可以动态的扩缩容，增加一个<strong>调度中心</strong>基于访问压力实时管理集群容量，提高集群利用率。</p>\n<p>此时，用于提高机器利用率的资源调度和治理中心(SOA)[ Service Oriented Architecture]是关键。</p>\n<img src=\"assets/SOA.png\" style=\"zoom:48%;\" /></li>\n</ul>\n<h1 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h1><p>Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC框架，它提供了三大核心能力：<strong>面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现</strong>。</p>\n<p><img src=\"assets%5Cimage-20210106144404533.png\" alt=\"image-20210106144404533\"></p>\n<ul>\n<li><p><strong>服务提供者（Provider）</strong>：暴露服务的服务提供方，服务提供者在启动时，向注册中心注册自己提供的服务。</p>\n</li>\n<li><p><strong>服务消费者（Consumer）</strong>: 调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</p>\n</li>\n<li><p><strong>注册中心（Registry）</strong>：注册中心返回服务提供者地址列表给消费者，<strong>如果有变更，注册中心将基于长连接推送变更数据给消费者</strong>。</p>\n</li>\n<li><p><strong>监控中心（Monitor）</strong>：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p>\n</li>\n</ul>\n<p>调用关系说明</p>\n<ol>\n<li>服务容器负责启动，加载，运行服务提供者。</li>\n<li>服务提供者在启动时，向注册中心注册自己提供的服务。</li>\n<li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li>\n<li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</li>\n<li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。</li>\n<li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li>\n</ol>\n<blockquote>\n<p>分布式系统可以不用dubbo吗？</p>\n<p>可以。各个系统之间直接基于spring mvc，纯http接口互相通信。但是http接口通信维护起来成本很高，要考虑超时重试、负载均衡等等问题。</p>\n<p>dubbo是一种rpc框架，就是在本地进行接口调用，但是dubbo会代理这个调用请求，跟远程机器网络通信，处理掉负载均衡、服务实例上下线自动感知、超时重试等等问题。</p>\n</blockquote>\n<h2 id=\"dubbo环境搭建\"><a href=\"#dubbo环境搭建\" class=\"headerlink\" title=\"dubbo环境搭建\"></a>dubbo环境搭建</h2><ul>\n<li>【windows】-安装zookeeper</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>1、下载zookeeper  网址 <a href=\"https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/\">https://archive.apache.org/dist/zookeeper/zookeeper-3.4.13/</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2、解压zookeeper  解压运行zkServer.cmd ，初次运行会报错，没有zoo.cfg配置文件</td>\n</tr>\n<tr>\n<td>3、修改zoo.cfg配置文件  将conf下的zoo_sample.cfg复制一份改名为zoo.cfg即可。  注意几个重要位置：  dataDir=./  临时数据存储的目录（可写相对路径）  clientPort=2181  zookeeper的端口号  修改完成后再次启动zookeeper</td>\n</tr>\n<tr>\n<td>4、使用zkCli.cmd测试  ls /：列出zookeeper根下保存的所有节点  create –e /atguigu 123：创建一个atguigu节点，值为123  get /atguigu：获取/atguigu节点的值</td>\n</tr>\n</tbody></table>\n<ul>\n<li>【windows】-安装dubbo-admin管理控制台</li>\n</ul>\n<p>dubbo本身并不是一个服务软件。它其实就是一个jar包能够帮你的java程序连接到zookeeper，并利用zookeeper消费、提供服务。所以你不用在Linux上启动什么dubbo服务。</p>\n<p>但是为了让用户更好的管理监控众多的dubbo服务，官方提供了一个可视化的监控程序，不过这个监控即使不装也不影响使用。</p>\n<table>\n<thead>\n<tr>\n<th>1、下载dubbo-admin  <a href=\"https://github.com/apache/incubator-dubbo-ops\">https://github.com/apache/incubator-dubbo-ops</a></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2、进入目录，修改dubbo-admin配置  修改 src\\main\\resources\\application.properties  指定zookeeper地址</td>\n</tr>\n<tr>\n<td>3、打包dubbo-admin  mvn clean package -Dmaven.test.skip=true</td>\n</tr>\n<tr>\n<td>4、运行dubbo-admin  java -jar dubbo-admin-0.0.1-SNAPSHOT.jar  注意：【有可能控制台看着启动了，但是网页打不开，需要在控制台按下ctrl+c即可】  默认使用root/root 登陆</td>\n</tr>\n</tbody></table>\n<h2 id=\"dubbo的通信协议\"><a href=\"#dubbo的通信协议\" class=\"headerlink\" title=\"dubbo的通信协议\"></a>dubbo的通信协议</h2><p>dubbo支持不同的通信协议</p>\n<ol>\n<li><p>dubbo协议（默认）</p>\n<p>dubbo://192.168.0.1:20188</p>\n<p><strong>单一长连接</strong>，<strong>NIO异步通信</strong>，基于<strong>hessian</strong>作为序列化协议 。</p>\n<p>适用的场景：<strong>传输数据量很小</strong>（每次请求在100kb以内），<strong>并发量很高</strong>。</p>\n<ul>\n<li><p>为了要支持高并发场景，一般是服务提供者就几台机器，但是服务消费者有上百台，可能每天调用量达到上亿次！此时用长连接是最合适的，就是跟每个服务消费者维持一个长连接就可以，然后直接基于长连接NIO异步通信，可以支撑高并发请求。</p>\n</li>\n<li><p>因为走的是单一长连接，所以传输数据量太大的话，会导致并发能力降低。所以一般建议是传输数据量很小，支撑高并发访问。</p>\n</li>\n</ul>\n</li>\n<li><p>rmi协议</p>\n<p>采用<strong>java二进制序列化</strong>，<strong>多个短连接</strong>，适合消费者和提供者数量差不多，适用于文件的传输，一般较少用。</p>\n</li>\n<li><p>hessian协议 </p>\n<p>采用<strong>hessian</strong>序列化协议，<strong>多个短连接</strong>，适用于提供者数量比消费者数量还多，适用于文件的传输，一般较少用</p>\n</li>\n<li><p>http协议</p>\n<p>采用<strong>json</strong>序列化</p>\n</li>\n<li><p>webservice</p>\n<p>采用<strong>SOAP文本</strong>序列化</p>\n</li>\n</ol>\n<p>dubbo基于不同的通信协议，支持hessian、java二进制序列化、json、SOAP文本序列化多种序列化协议。但是hessian是其默认的序列化协议。</p>\n<ul>\n<li><strong>hessian序列化</strong>：Java 对象序列化的二进制流可以被其他语言 （ 如 C＋＋、 Python ）反序列化。默认支持跨语言，比Java原生序列化高效，但是效率依旧不高。</li>\n<li><strong>Java原生序列化</strong>：Java类通过实现Serializable接口来实现该类对象的序列化。Java序列化保留了对象类的元数据（如类、成员变量、继承类信息等），以及对象数据等。使用方便，可序列化所有类（兼容性最好），但是速度慢，占空间，不支持跨语言。</li>\n<li><strong>JSON序列化</strong>：轻量级的数据交换格式。将数据对象转换为 JSON 字符串。在序列化过程中抛弃了类型信息，所以反序列化时只有提供类型信息才能准确地反序列化。相比前两种方式，JSON 可读性比较好，方便调试。</li>\n</ul>\n<h1 id=\"高可用\"><a href=\"#高可用\" class=\"headerlink\" title=\"高可用\"></a>高可用</h1><h2 id=\"1-zookeeper宕机\"><a href=\"#1-zookeeper宕机\" class=\"headerlink\" title=\"1. zookeeper宕机\"></a>1. zookeeper宕机</h2><p>现象：zookeeper注册中心宕机，还可以消费dubbo暴露的服务。</p>\n<p>原因：</p>\n<ul>\n<li><p>注册中心对等集群，任意一台宕掉后，将自动切换到另一台。</p>\n</li>\n<li><p>注册中心全部宕掉后，服务提供者和服务消费者仍能通过<strong>本地缓存</strong>通讯，但不能注册新服务</p>\n</li>\n</ul>\n<p>高可用：通过设计，减少系统不能提供服务的时间；</p>\n<h2 id=\"2-dubbo直连\"><a href=\"#2-dubbo直连\" class=\"headerlink\" title=\"2. dubbo直连\"></a>2. dubbo直连</h2><p>自动注入属性的时候设置服务提供者的url，比如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//服务消费者</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OrderServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">OrderService</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//@Autowired</span></span><br><span class=\"line\">\t<span class=\"meta\">@Reference(url=&quot;127.0.0.1:20882&quot;)</span> <span class=\"comment\">//dubbo直连</span></span><br><span class=\"line\">\tUserService userService;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"3-集群下dubbo负载均衡配置\"><a href=\"#3-集群下dubbo负载均衡配置\" class=\"headerlink\" title=\"3. 集群下dubbo负载均衡配置\"></a>3. 集群下dubbo负载均衡配置</h2><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 random 随机调用。</p>\n<p>负载均衡策略：</p>\n<ol>\n<li><p><strong>Random LoadBalance</strong> —— 随机，按权重设置随机概率。</p>\n</li>\n<li><p><strong>RoundRobin LoadBalance</strong> —— 轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求的问题。</p>\n</li>\n<li><p><strong>LeastActive LoadBalance</strong> —— 最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。（获取每台机器的活跃数，求得最小活跃数，活跃数都等于最小活跃数的机器中根据权重随机获取）</p>\n<p>每个服务维护一个活跃数计数器，即正在处理的请求数。当A机器开始处理请求，该计数器加1，此时A还未处理完成。而B机器接受到请求后很快处理完毕。那么A,B的活跃数分别是1，0。当又产生了一个新的请求，则选择B机器去执行(B活跃数最小)，这样使慢的机器A收到少的请求。</p>\n</li>\n<li><p><strong>ConsistentHash LoadBalance</strong> —— 一致性 Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。</p>\n</li>\n</ol>\n<p>怎么调整权重？</p>\n<p><strong>根据机器的性能</strong>，如8核+16G的权重为2，4核+8G的权重为1。</p>\n<h2 id=\"4-服务降级\"><a href=\"#4-服务降级\" class=\"headerlink\" title=\"4. 服务降级\"></a>4. 服务降级</h2><p><strong>当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。</strong></p>\n<p>可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。</p>\n<ol>\n<li><p>Mock Null服务降级处理</p>\n<ul>\n<li>mock=force:return+null 表示<strong>消费方对该服务的方法调用都直接返回 null 值，不发起远程调用</strong>。用来屏蔽不重要服务不可用时对调用方的影响。</li>\n<li>mock=fail:return+null 表示<strong>消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常</strong>。用来容忍不重要服务不稳定时对调用方的影响。</li>\n</ul>\n</li>\n<li><p>Mock Class服务降级处理</p>\n<p>mock=”true”，在业务接口所在的包中定义一个类，该类的命名需要满足以下规则：业务接口简单类名 + Mock。然后在这个类里实现自己的降级逻辑。</p>\n</li>\n</ol>\n<h2 id=\"5-超时重试\"><a href=\"#5-超时重试\" class=\"headerlink\" title=\"5. 超时重试\"></a>5. 超时重试</h2><p>consumer调用provider失败，比如抛异常了，此时应该是可以重试的，或者调用超时了也可以重试。如果是超时了，timeout就会设置超时时间；如果是调用失败了自动就会重试指定（retries）的次数。</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dubbo:reference</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;xxxx&quot;</span> <span class=\"attr\">interface</span>=<span class=\"string\">&quot;xx&quot;</span> <span class=\"attr\">check</span>=<span class=\"string\">&quot;true&quot;</span> <span class=\"attr\">async</span>=<span class=\"string\">&quot;false&quot;</span> <span class=\"attr\">retries</span>=<span class=\"string\">&quot;3&quot;</span> <span class=\"attr\">timeout</span>=<span class=\"string\">&quot;2000&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"6-集群容错\"><a href=\"#6-集群容错\" class=\"headerlink\" title=\"6. 集群容错\"></a>6. 集群容错</h2><p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p>\n<p><strong>集群容错模式</strong></p>\n<ol>\n<li><strong>Failover Cluster（默认）</strong>  <strong>失败自动切换</strong>，当出现失败，重试其它服务器。通常用于<strong>读操作</strong>，但重试会带来更长延迟。可通过 retries=”2” 来设置重试次数(不含第一次)。</li>\n<li><strong>Failfast  Cluster</strong>  快速失败，只发起一次调用，失败立即报错。通常用于<strong>非幂等性的写操作</strong>，比如新增记录。</li>\n<li><strong>Failsafe  Cluster</strong>  失败安全，出现异常时，直接忽略。通常用于<strong>写入审计日志</strong>等操作。</li>\n<li><strong>Failback  Cluster</strong>  失败自动恢复，后台记录失败请求，定时重发。通常用于<strong>消息通知</strong>操作。</li>\n<li><strong>Forking  Cluster</strong>  并行调用多个服务器，只要一个成功即返回。通常用于<strong>实时性要求较高的读操作</strong>，但需要浪费更多服务资源。可通过  forks=”2” 来设置最大并行数。</li>\n<li><strong>Broadcast  Cluster</strong>  <strong>广播</strong>调用所有提供者，<strong>逐个调用</strong>，任意一台报错则报错。通常用于<strong>通知所有提供者更新缓存或日志</strong>等本地资源信息。     </li>\n</ol>\n<p><strong>集群模式配置</strong>  按照以下示例在服务提供方和消费方配置集群模式  &lt;dubbo:service  cluster=”failsafe” /&gt;  或  &lt;dubbo:reference  cluster=”failsafe” /&gt;  </p>\n<p>通过整合hystrix来进行容错</p>\n<p>Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。</p>\n<p>Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能。</p>\n<h2 id=\"7-动态代理策略\"><a href=\"#7-动态代理策略\" class=\"headerlink\" title=\"7. 动态代理策略\"></a>7. 动态代理策略</h2><ol>\n<li><p>默认使用javassist动态字节码生成，创建代理类</p>\n</li>\n<li><p>通过SPI扩展机制配置自己的动态代理策略</p>\n</li>\n</ol>\n<h1 id=\"SPI机制\"><a href=\"#SPI机制\" class=\"headerlink\" title=\"SPI机制\"></a>SPI机制</h1><p><a href=\"http://blog.itpub.net/31559758/viewspace-2678246/\">dubbo的SPI应用与原理</a></p>\n<p><a href=\"https://blog.csdn.net/yangbaggio/article/details/97617750\">Dubbo的SPI机制</a></p>\n<p><a href=\"https://blog.csdn.net/qq_35190492/article/details/108256452?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_baidulandingword-14&spm=1001.2101.3001.4242\">阿里面试真题：Dubbo的SPI机制</a></p>\n<p><strong>SPI(Service Provider Interface)</strong></p>\n<ul>\n<li>本质是 <strong>将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类</strong>。这样可以在运行时，动态为接口替换实现类。</li>\n<li>在Java中SPI是被用来设计给服务提供商做插件使用的。基于策略模式 来<strong>实现动态加载的机制</strong> 。我们在程序只定义一个接口，具体的实现交个不同的服务提供者；在程序启动的时候，读取配置文件，由配置确定要调用哪一个实现；</li>\n<li>通过 SPI 机制为我们的程序提供拓展功能，在dubbo中，基于 SPI，我们可以很容易的对 Dubbo 进行拓展。例如dubbo当中的protocol，LoadBalance等都是通过SPI机制扩展。</li>\n</ul>\n<h2 id=\"Java原生SPI机制\"><a href=\"#Java原生SPI机制\" class=\"headerlink\" title=\"Java原生SPI机制\"></a>Java原生SPI机制</h2><p><a href=\"https://mp.weixin.qq.com/s?__biz=MzIxNDY0MTg2MA==&mid=2247483935&idx=1&sn=e6da46cfe2df2812fd2b9e24253ec246&chksm=97a53fb4a0d2b6a2896b5c0850e83a7852ad08fbe0939bb61d04982bc0d03d3f6da25ee56dbf&scene=21#wechat_redirect\">谈谈Java的SPI机制</a></p>\n<p>在java中根据一个子类获取其父类或接口信息非常方便，但是根据一个接口获取该接口的所有实现类却没那么容易。</p>\n<p>java推出了ServiceLoader类来提供<strong>服务发现机制</strong>，通过引入jar包，动态地为某个接口寻找服务实现，而不需要手动配置。</p>\n<p>当服务的提供者提供了服务接口的一种实现之后，必须根据SPI约定在 <code>META-INF/services/</code> 目录里创建一个以服务接口命名的文件，该文件里写的就是实现该服务接口的具体实现类。当程序调用ServiceLoader的load方法的时候，ServiceLoader能够通过约定的目录找到指定的文件，并装载实例化，完成服务的发现。</p>\n<p>如JDBC、日志框架等都有用到SPI机制。</p>\n<p>JDBC只需下面的一行代码，再提供商不同厂商的jar包，就可以轻松创建连接。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connection conn = DriverManager.getConnection(URL, USER, PASSWORD);</span><br></pre></td></tr></table></figure>\n\n<img src=\"assets\\aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNjAzNDI3OS03N2RiNDJkNjU0M2EwMzgzLnBuZw.png\" style=\"zoom:67%;\" />\n\n<p>缺点：</p>\n<ul>\n<li><strong>不能按需加载</strong>。Java SPI在加载扩展点的时候，会一次性加载所有可用的扩展点，很多是不需要的，会浪费系统资源；</li>\n<li>获取某个实现类的方式不够灵活，只能通过 Iterator 形式获取，<strong>不能根据某个参数来获取对应的实现类</strong>。</li>\n<li><strong>不支持AOP与依赖注入</strong>。</li>\n<li>JAVA SPI可能会丢失加载扩展点异常信息，导致追踪问题很困难；</li>\n</ul>\n<p>源码分析：</p>\n<p><a href=\"https://houbb.github.io/2018/08/02/spi-03-java-source-code\">spi 03-spi jdk 实现源码解析</a></p>\n<ul>\n<li><p><code>ServiceLoader.load(service,  classloader);</code>创建ServiceLoader实例</p>\n<p>service是Class类型的，即接口</p>\n</li>\n<li><p>在<code>new ServiceLoader()</code>的构造方法中，会进行reload()</p>\n</li>\n<li><p>reload()</p>\n<ul>\n<li>清空providers（保存接口的实现类），每次初始化前都会清空</li>\n<li>new LazyIterator(service, loader)</li>\n</ul>\n</li>\n<li><p>LazyIterator实现了Iterator接口</p>\n<p>Enumeration&lt;URL&gt; configs保存所有名为接口全限定类名的文件</p>\n<p>Iterator&lt;String&gt; pending 保存文件中的类名</p>\n<p>String nextname保存迭代器迭代到的类名</p>\n<ul>\n<li><p>boolean hasNextService()</p>\n<ul>\n<li><p>nextname!=null 直接返回true</p>\n</li>\n<li><p>config为null，去META-INF/services路径下，获取所有名为接口全限定类名的文件，保存在configs中。</p>\n</li>\n<li><p>解析文件，按行读取，保存在pending中。</p>\n</li>\n<li><p>nextname=pending.next();</p>\n</li>\n</ul>\n</li>\n<li><p>nextService()</p>\n<p>反射获取类文件，创建实例，放入providers，并返回实例。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>虽然Java SPI是懒加载的，但是要获取制定的类还是要遍历所有的类，也就是把所有的类都实例化。</p>\n<h2 id=\"dubbo-SPI\"><a href=\"#dubbo-SPI\" class=\"headerlink\" title=\"dubbo SPI\"></a>dubbo SPI</h2><p>​        dubbo重新实现了一套功能更强的 SPI 机制，<strong>支持了AOP与依赖注入</strong>，并且 <strong>利用缓存</strong>提高加载实现类的性能，同时 <strong>支持实现类的灵活获取</strong>。</p>\n<p>例如：实现消费者调用远程方法时，服务端在控制台输出调用记录的过滤器。</p>\n<p><img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804151123294.png\" alt=\"image-20210804151123294\"></p>\n<p><strong>Dubbo SPI原理：</strong></p>\n<img src=\"assets\\aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xNjAzNDI3OS01ZGZlMmMzNmJmM2NlOGYyLnBuZw.png\" style=\"zoom:67%;\" />\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ExtensionLoader.getExtensionLoader(xxx.class).getExtension(name)</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>getExtensionLoader() ：从缓存里面找是否已经存在这个类型的 ExtensionLoader ，如果没有就新建一个塞入缓存。最后返回接口类对应的 ExtensionLoader 。</li>\n<li>getExtension(name)：通过 <code>getExtension</code>方法获取需要拓展类对象。先找实现类，判断缓存是否有实例，没有就执行createExtension()。<ul>\n<li>createExtension()<ul>\n<li>getExtensionClasses()获取实现类：加载配置获得Map&lt;String, Class&gt;，返回Class</li>\n<li>反射创建实现类</li>\n<li>injectExtension()：依赖注入</li>\n<li>如果有找到包装类的话，再包一层</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<img src=\"assets\\1583212844170830.png\" style=\"zoom:80%;\" />\n\n<p><a href=\"https://houbb.github.io/2018/08/02/spi-04-dubbo-spi\">spi 04-spi dubbo 实现源码解析</a></p>\n<p>① 先检查缓存中是否存在扩展类；<br>② 缓存未命中，会通过接口名在META-INF/services/、MEAT-INF/dubbo/、META-INF/dubbo/internal/三个目录下查找配置文件；<br>③ 从这个配置文件中加载所有的拓展类，可得到“配置项名称”到“配置类”的映射关系表；<br>④ 通过反射创建需要的拓展对象，并放入缓存；<br>⑤ 向拓展对象中注入依赖（IOC，setter方法）；<br>⑥ 将拓展对象包裹在相应的 Wrapper 对象中（AOP）。</p>\n<h2 id=\"Dubbo的自适应扩展机制\"><a href=\"#Dubbo的自适应扩展机制\" class=\"headerlink\" title=\"Dubbo的自适应扩展机制\"></a>Dubbo的自适应扩展机制</h2><p><strong>不在启动的时候让扩展被加载，而是根据请求时候的参数来动态选择对应的扩展。</strong></p>\n<p><strong>Dubbo 通过一个代理机制实现了自适应扩展</strong>，简单的说就是为你想扩展的接口生成一个代理类，可以通过JDK 或者 javassist 编译你生成的代理类代码，然后通过反射创建实例。这个实例里面的实现会根据本来方法的请求参数得知需要的扩展类，然后通过 <code>ExtensionLoader.getExtensionLoader(type.class).getExtension(从参数得来的name)</code>，来获取真正的实例来调用。</p>\n<p><strong>Adaptive 注解</strong>就是自适应扩展相关的注解，可以修饰类和方法上</p>\n<ul>\n<li>在修饰类的时候不会生成代理类，因为这个类就是代理类</li>\n<li>修饰在方法上的时候会生成代理类。</li>\n</ul>\n<p>具体加载步骤：</p>\n<p>示例见：<a href=\"https://my.oschina.net/zhangxufeng/blog/3058009\">Dubbo Adaptive机制详解</a></p>\n<p>源码分析见：<a href=\"https://houbb.github.io/2018/08/02/spi-05-dubbo-adaptive-extension\">spi 05-dubbo adaptive extension 自适应拓展</a></p>\n<p>示例：</p>\n<p>水果种植者接口</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SPI(&quot;apple&quot;)</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">FruitGranter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\">Fruit <span class=\"title\">grant</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Adaptive</span></span><br><span class=\"line\">  <span class=\"function\">String <span class=\"title\">watering</span><span class=\"params\">(URL url)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实现类</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 苹果种植者</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AppleGranter</span> <span class=\"keyword\">implements</span> <span class=\"title\">FruitGranter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Fruit <span class=\"title\">grant</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Apple();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">watering</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;watering apple&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;watering finished&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 香蕉种植者</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BananaGranter</span> <span class=\"keyword\">implements</span> <span class=\"title\">FruitGranter</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> Fruit <span class=\"title\">grant</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Banana();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Override</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">watering</span><span class=\"params\">(URL url)</span> </span>&#123;</span><br><span class=\"line\">    System.out.println(<span class=\"string\">&quot;watering banana&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;watering success&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在META-INF/dubbo创建文件，该文件的名称是目标接口的全限定名，这里是<code>org.apache.dubbo.demo.example.eg19.FruitGranter</code>，在该文件中需要指定该接口所有可提供服务的子类，形式如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apple=org.apache.dubbo.demo.example.eg19.AppleGranter</span><br><span class=\"line\">banana=org.apache.dubbo.demo.example.eg19.BananaGranter</span><br></pre></td></tr></table></figure>\n\n<p>测试类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExtensionLoaderTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"meta\">@Test</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">testGetExtensionLoader</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首先创建一个模拟用的URL对象</span></span><br><span class=\"line\">    URL url = URL.valueOf(<span class=\"string\">&quot;dubbo://192.168.0.101:20880?fruit.granter=apple&quot;</span>);</span><br><span class=\"line\">    <span class=\"comment\">// 通过ExtensionLoader获取一个FruitGranter对象</span></span><br><span class=\"line\">    FruitGranter granter = ExtensionLoader.getExtensionLoader(FruitGranter.class)</span><br><span class=\"line\">      .getAdaptiveExtension();</span><br><span class=\"line\">    <span class=\"comment\">// 使用该FruitGranter调用其&quot;自适应标注的&quot;方法，获取调用结果</span></span><br><span class=\"line\">    String result = granter.watering(url);</span><br><span class=\"line\">    System.out.println(result);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>源码分析：</p>\n<ul>\n<li><p><code>T getAdaptiveExtension()</code></p>\n<ul>\n<li>缓存中获取自适应拓展</li>\n<li>未命中则创建自适应扩展<code>T createAdaptiveExtension()</code>，并设置进缓存。</li>\n</ul>\n</li>\n<li><p><code>T createAdaptiveExtension()</code></p>\n<ul>\n<li><code>Class&lt;?&gt; getAdaptiveExtensionClass()</code>获取自适应拓展类文件</li>\n<li>反射实例化</li>\n<li><code>injectExtension</code>向拓展实例中进行依赖注入，仅支持setter方式的注入</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">createAdaptiveExtension</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 获取自适应拓展类，反射实例化，依赖注入</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException(<span class=\"string\">&quot;Can not create adaptive extension ...&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>Class&lt;?&gt; getAdaptiveExtensionClass()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// SPI 获取所有的拓展类，获取过程中，如果发现某个类被Adaptive修饰，则被放入缓存cachedAdaptiveClass</span></span><br><span class=\"line\">    getExtensionClasses();</span><br><span class=\"line\">    <span class=\"comment\">// 若缓存不为空，则直接返回缓存</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (cachedAdaptiveClass != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cachedAdaptiveClass;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 缓存为空，创建自适应拓展类</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> cachedAdaptiveClass = createAdaptiveExtensionClass();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>Class&lt;?&gt; createAdaptiveExtensionClass()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 构建自适应拓展代码</span></span><br><span class=\"line\">    String code = createAdaptiveExtensionClassCode();</span><br><span class=\"line\">    ClassLoader classLoader = findClassLoader();</span><br><span class=\"line\">    <span class=\"comment\">// 获取编译器实现类</span></span><br><span class=\"line\">    com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class=\"line\">    <span class=\"comment\">// 通过jdk或者javassist的方式编译上面生成的code，从而得到一个class对象</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> compiler.compile(code, classLoader);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>String createAdaptiveExtensionClassCode()</code></p>\n<p>该方法主要是拼接了一个类名为FruitGranter$Adaptive的java文件。</p>\n<ul>\n<li><p>通过反射获取接口（例子中的FruitGranter接口）的所有方法。</p>\n<ul>\n<li><p>所有未使用<code>@Adaptive</code>注解标注的接口方法，默认都会抛出异常；</p>\n</li>\n<li><p>在使用<code>@Adaptive</code>注解标注的方法中，其参数中必须有一个参数类型为URL，或者其某个参数提供了某个方法，该方法可以返回一个URL对象；</p>\n<p>获取方法参数中类型为URL的参数，如果不存在，则在该方法的参数所对应的类中，查找返回URL类型对象的方法，并调用该方法获取URL对象。</p>\n</li>\n</ul>\n</li>\n<li><p>通过<code>@Adaptive</code>注解的配置获取目标参数的key值，然后通过前面得到的URL对象获取该key对应的参数值，从而得到了基础服务类对应的名称；</p>\n<ul>\n<li><p>如果在URL中没有获取到对应的参数值，那么就会使用@SPI注解中配置的默认值（示例中的apple）</p>\n</li>\n<li><p>在通过URL对象获取参数时，参数key获取的对应规则是，首先会从<code>@Adaptive</code>注解的参数值中获取，如果该注解没有指定参数名，那么就会默认将目标接口的类名转换为点分形式作为参数名，比如这里<code>FruitGranter</code>转换为点分形式就是<code>fruit.granter</code>。</p>\n</li>\n</ul>\n</li>\n<li><p>通过<code>ExtensionLoader</code>获取该名称对应的基础服务类实例；</p>\n</li>\n<li><p>通过调用基础服务类的实例的当前方法来实现最终的基础服务。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Dubbo工作原理\"><a href=\"#Dubbo工作原理\" class=\"headerlink\" title=\"Dubbo工作原理\"></a>Dubbo工作原理</h1><p><a href=\"D:\\Java\\java学习\\Dubbo相关\\尚硅谷Dubbo视频\\课件、资料\\课件\\dubbo-原理流程.vsdx\">原理图</a></p>\n<ol>\n<li>启动解析、加载配置信息</li>\n<li>服务暴露<ul>\n<li>DubboProtocol() ：openServer()方法会创建netty服务器，并监听dubbo通信端口。</li>\n<li>RegistryProtocol() ：将服务的对应信息保存在注册表中（注册提供者）。</li>\n</ul>\n</li>\n<li>服务引用<ul>\n<li>DubboProtocol() ：refer()引用远程服务，连接获取客户端</li>\n<li>RegistryProtocol() ：订阅服务，把客户端信息保存到注册表中</li>\n</ul>\n</li>\n</ol>\n<p>原理简介：</p>\n<img src=\"assets\\01_dubbo的工作原理.png\" style=\"zoom:80%;\" />\n\n<p>第一层：service层，接口层，给服务提供者和消费者来实现的</p>\n<p>第二层：config层，配置层，主要是对dubbo进行各种配置的</p>\n<p>第三层：proxy层，服务代理层，透明生成客户端的stub和服务端的skeleton</p>\n<p>第四层：registry层，服务注册层，负责服务的注册与发现</p>\n<p>第五层：cluster层，集群层，封装多个服务提供者的路由以及负载均衡，将多个实例组合成一个服务</p>\n<p>第六层：monitor层，监控层，对rpc接口的调用次数和调用时间进行监控</p>\n<p>第七层：protocol层，远程调用层，封装rpc调用</p>\n<p>第八层：exchange层，信息交换层，封装请求响应模式，同步转异步</p>\n<p>第九层：transport层，网络传输层，抽象mina和netty为统一接口</p>\n<p>第十层：serialize层，数据序列化层</p>\n<p>工作流程：</p>\n<ol>\n<li>provider向注册中心去注册</li>\n<li>consumer从注册中心订阅服务，注册中心会通知consumer注册好的服务</li>\n<li>consumer调用provider</li>\n<li>consumer和provider都异步的通知监控中心</li>\n</ol>\n<p><a href=\"https://www.cnblogs.com/jackion5/p/11219707.html\">通俗易懂描述dubbo工作原理</a></p>\n<ol>\n<li><p>Spring容器启动时，BeanDefinitionParser标签解析器解析标签，其中&lt;dubbo:service&gt;标签（配置注册中心、应用名、节点地址、通信协议等一系列参数）解析为<strong>ServiceBean</strong>对象，&lt;dubbo:reference&gt;标签解析为<strong>ReferenceBean</strong>对象。</p>\n</li>\n<li><p>provider暴露服务</p>\n<p>ServiceBean实现了Spring的InitializingBean、ApplicationListener&lt;ContextRefreshedEvent&gt;等接口，所以当spring启动完成之后：</p>\n<ul>\n<li>InitializingBean会使其回调afterPropertiesSet(…)方法，保存dubbo标签中的信息到ServiceBean中。将这些配置信息进行组装到一起，封装成了一个URL对象，一个URL对象就包含了一个服务所有的信息，包含了接口到方法名称、参数列表、dubbo的配置信息等。</li>\n<li>ApplicationListener&lt;ContextRefreshedEvent&gt;会使其回调onApplicationEvent(…)方法，将要暴露还没有暴露的服务暴露出去。</li>\n<li>通过代理工厂获得要暴露还未暴露的服务的invoker对象，该对象中包装了要暴露对象的实例，url地址等信息。</li>\n<li>不同的协议要实现Protocol接口的export()来暴露服务<ul>\n<li>RegistryProtocol注册服务到注册中心（将provider地址保存到全局map中，key：url地址，value：对应服务的Exporter对象（Exporter对象可以调用getInvoker()得到这个服务的Invoker对象，得到了这个Invoker对象就可以执行具体服务的方法了））</li>\n<li>dubboProtocol启动Netty服务器，监听端口。</li>\n</ul>\n</li>\n</ul>\n<p>总结：需要根据不同的协议去暴露服务，所以需要执行不同协议对象procotol实现类，<strong>每个procotol中有一个Map，key为服务的唯一标识，value为Exporter对象；Exporter对象可以调用getInvoker()得到这个服务的Invoker对象（方法执行体），得到了这个Invoker对象就可以执行具体服务的方法了。</strong></p>\n<p><strong>暴露服务的方法为 export()方法：Invoker —&gt; Exporter，打开 socket 侦听服务，以接收客户端发来的各种请求。</strong></p>\n</li>\n<li><p>consumer引入服务</p>\n<ul>\n<li>ReferenceBean实现了FactoryBean接口，当需要消费服务时，首先的从容器中获取bean也就是执行getObject()得到，此时就会在getObject方法中执行init()方法去引入服务。</li>\n<li>执行init方法时首先也是进行dubbo配置的读取和加载等，并且将一切配置信息（注册中心地址、调用的方法、调用的接口等）整合到一个map中。</li>\n<li><strong>RegistryProtocol</strong>的refer方法：从注册中心订阅服务，将注册信息保存到注册表中。</li>\n<li>消费者根据配置信息的map创建了URL对象，然后通过<strong>DubboProcotol</strong>的refer方法与服务器<strong>创建连接</strong>，可以获取到一个Invoker对象，这个Invoker对象就是可以执行服务的方法的执行体。<ul>\n<li>invoker对象的创建过程会和服务提供者进行连接，以netty为例子就是创建了Netty的客户端和提供者那边的Netty服务端进行连接，然后得到的连接对象和服务信息共同构造出了invoker对象</li>\n</ul>\n</li>\n<li>消费者不能直接使用Invoker，而是采用了<strong>代理模式</strong>，通过字节码生成技术，根据invoker对象动态生成了一个服务的实现类。</li>\n</ul>\n<p><strong>总结：服务引入的过程实际就是作为一个客户端，创建了和服务器的一个连接，得到了一个invoker对象，并通过invoker对象动态代理的方式得到服务的实现类，实现类的方法执行实际就是通过invoker来执行的。</strong></p>\n<p><strong>refer()方法与服务器创建连接，获取到一个Invoker对象，以便在本地调用。</strong></p>\n<p>消费者端的invoker，我的理解是为了能够在本地代码中调用远程方法而设置的一个接口实例，不是真正的方法执行体。</p>\n</li>\n<li><p>provider和consumer的服务调用</p>\n<ul>\n<li><p>消费端从注册中心获得Invoker，通过负载均衡机制选取一个invoker。</p>\n</li>\n<li><p>Invoker将执行的方法转化成字节流的形式通过网络通信发送给服务端，当然首先需要进行序列化，默认采用netty通信。</p>\n</li>\n<li><p>服务端接收到字节流信息首先是进行解码，得到请求的具体参数，根据请求内容就可以得到是对应得Exporter对象，根据Exporter对象可以获取Invoker对象，然后通过Invoker来执行具体的方法。</p>\n</li>\n<li><p>服务端得到结果后通过网络返回给消费端。</p>\n</li>\n</ul>\n<img src=\"assets\\822135-20190720224216104-761168332.jpg\" style=\"zoom:80%;\" /></li>\n</ol>\n","categories":[],"tags":[]}