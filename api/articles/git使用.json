{"title":"Git","slug":"git使用","date":"2021-08-04T16:00:00.000Z","updated":"2021-08-05T09:07:01.253Z","comments":true,"path":"api/articles/git使用.json","photos":[],"link":"","excerpt":null,"covers":["https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804180015349.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804180812770.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804192111858.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804192709942.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804192752090.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804192723551.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804192948388.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804193034978.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804194013103.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804194944167.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804195235101.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804195707129.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804200722263.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804201748390.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804202320753.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804202331841.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804205157287.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804205214864.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804204300984.png","https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804204632156.png"],"content":"<h1 id=\"Git\"><a href=\"#Git\" class=\"headerlink\" title=\"Git\"></a>Git</h1><p><a href=\"https://git-scm.com/book/zh/v2\">中文Git官方文档</a></p>\n<h2 id=\"一、Git工作原理\"><a href=\"#一、Git工作原理\" class=\"headerlink\" title=\"一、Git工作原理\"></a>一、Git工作原理</h2><h3 id=\"1-Git工作区、暂存区和提交区\"><a href=\"#1-Git工作区、暂存区和提交区\" class=\"headerlink\" title=\"1.Git工作区、暂存区和提交区\"></a>1.Git工作区、暂存区和提交区</h3><p><a href=\"https://www.runoob.com/git/git-workspace-index-repo.html\">Git 工作区、暂存区和版本库</a></p>\n<ul>\n<li><p><strong>HEAD</strong>：当前分支引用的指针，它总是指向该分支上的最后一次提交。 这表示 HEAD 将是下一次提交的父结点。</p>\n</li>\n<li><p><strong>暂存区（索引）</strong>：预期的下一次提交。</p>\n</li>\n<li><p><strong>工作区</strong>：工作目录。</p>\n</li>\n</ul>\n<img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804180015349.png\" alt=\"image-20210804180015349\" style=\"zoom:67%;\" />\n\n<p>基本命令：</p>\n<ul>\n<li><p><strong>git init</strong>：将本地目录转化为Git仓库</p>\n</li>\n<li><p>**git add &lt;file&gt;**：暂存文件，将工作区修改的文件放入暂存区</p>\n</li>\n<li><p><strong>git commit</strong> <strong>-m</strong> <strong>“提交信息”：</strong>提交暂存区文件。</p>\n<p>​    -a：跳过使用暂存区域，直接提交，无需git add</p>\n</li>\n<li><p><strong>git rm &lt;file&gt;</strong> <strong>：</strong>从暂存区和工作区移除文件</p>\n<p>​    -f：强制删除之前修改过或已经放到暂存区的文件  –cached：仅删除暂存区文件</p>\n</li>\n<li><p><strong>git</strong> <strong>checkout</strong> <strong>– &lt;file&gt;<strong>：还未暂存的文件，</strong>将工作区文件替换为暂存区的文件</strong></p>\n</li>\n<li><p><strong>git</strong> <strong>checkout</strong> <strong>HEAD &lt;file&gt;<strong>：已经暂存的文件，</strong>将暂存取和工作区的文件替换为HEAD指针指向的提交节点的文件</strong></p>\n</li>\n</ul>\n<h3 id=\"2-文件的四种状态\"><a href=\"#2-文件的四种状态\" class=\"headerlink\" title=\"2.文件的四种状态\"></a>2.文件的四种状态</h3><img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804180812770.png\" alt=\"image-20210804180812770\" style=\"zoom:50%;\" />\n\n\n\n<ul>\n<li><p><strong>git status</strong>：查看文件状态，当前所在分支。</p>\n<p>-s或者–short：状态概览。新添加的未跟踪文件前面有 ?? 标记，新添加到暂存区中的文件前面有 A 标记，修改过的文件前面有 M 标记。 输出中有两栏，左栏指明暂存区的状态，右栏指明工作区的状态。</p>\n</li>\n<li><p><strong>git diff</strong>：查看尚未暂存的文件更新了哪些部分，工作目录中当前文件和暂存区域快照之间的差异。</p>\n<p>–staged或者–cached：查看已暂存文件与最后一次提交的文件差异。</p>\n</li>\n</ul>\n<h2 id=\"二、Git存储方式\"><a href=\"#二、Git存储方式\" class=\"headerlink\" title=\"二、Git存储方式\"></a>二、Git存储方式</h2><p>Git仓库中存在一个.git的隐藏文件夹。</p>\n<img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804192111858.png\" alt=\"image-20210804192111858\" style=\"zoom:50%;\" />\n\n<h3 id=\"objects（对象数据库）\"><a href=\"#objects（对象数据库）\" class=\"headerlink\" title=\"objects（对象数据库）\"></a>objects（对象数据库）</h3><p><a href=\"https://blog.csdn.net/u014609638/article/details/85237977\">【Git常用】之深入理解Git存储文档的方式</a></p>\n<p>Git采用<strong>树结构</strong>保存数据，以SHA-1值作为索引：</p>\n<ul>\n<li><p><strong>Blob数据对象：</strong>文件内容。</p>\n</li>\n<li><p><strong>Tree树对象：</strong>包含了一条或多条树对象记录（tree entry），每条记录含有一个指向<strong>数据对象</strong>或者<strong>子树对象</strong>的 SHA-1 指针，以及相应的模式、类型、文件名信息。</p>\n</li>\n<li><p><strong>Commit提交对象：</strong>记录了一些本次提交的重要内容，如提交者、作者、附注、以及<strong>指向tree的指针（tree）</strong>和<strong>指向父提交的指针（parent）</strong>。</p>\n</li>\n</ul>\n<img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804192709942.png\" alt=\"image-20210804192709942\" style=\"zoom:50%;\" />\n\n<img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804192752090.png\" alt=\"image-20210804192752090\" style=\"zoom:50%;\" />\n\n<img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804192723551.png\" alt=\"image-20210804192723551\" style=\"zoom:50%;\" />\n\n<blockquote>\n<p><code>git cat-file -t &lt;commitHash&gt;</code> ：可以让 Git 告诉我们其内部存储的任何对象类型，只要给定该对象的 SHA-1 值。</p>\n</blockquote>\n<h3 id=\"Git底层实现\"><a href=\"#Git底层实现\" class=\"headerlink\" title=\"Git底层实现\"></a>Git底层实现</h3><p><a href=\"https://baijiahao.baidu.com/s?id=1667917800036579745&wfr=spider&for=pc\">图文并茂，详细讲解Git底层存储原理</a></p>\n<p>假设project目录下存在两个文件file1和file2:</p>\n<img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804192948388.png\" alt=\"image-20210804192948388\" style=\"zoom:30%;\" />\n\n<p><img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804193034978.png\" alt=\"image-20210804193034978\"></p>\n<h2 id=\"三、Git分支\"><a href=\"#三、Git分支\" class=\"headerlink\" title=\"三、Git分支\"></a>三、Git分支</h2><p>Git 的分支本质上仅仅是指向提交对象的可变<strong>指针</strong>，因此创建分支其实只是创建了一个指针。</p>\n<ul>\n<li><p>分支保存在**refs/heads/**文件夹下，文件中保存相应提交节点的SHA-1值。</p>\n</li>\n<li><p>master分支由git在init或者clone时自动生成。</p>\n</li>\n<li><p>HEAD保存当前所处的本地分支。</p>\n</li>\n</ul>\n<h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><ol>\n<li><p>创建分支：</p>\n<p><strong>git branch &lt;分支名&gt;</strong> </p>\n<p>在当前所在的提交对象上创建分支，但是并  不切换到新创建的分支上</p>\n</li>\n<li><p>分支切换：</p>\n<p><strong>git checkout &lt;分支名&gt;/&lt;commitHash&gt;</strong></p>\n<p>HEAD移动到指定分支或者提交节点</p>\n</li>\n<li><p>分支创建并切换：</p>\n<p><strong>git checkout -b &lt;分支名&gt;</strong></p>\n</li>\n</ol>\n<p>在当前节点创建testing分支：</p>\n<img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804194013103.png\" alt=\"image-20210804194013103\" style=\"zoom:50%;\" />\n\n\n\n<h3 id=\"分支管理相关命令\"><a href=\"#分支管理相关命令\" class=\"headerlink\" title=\"分支管理相关命令\"></a>分支管理相关命令</h3><ul>\n<li><p><strong>git branch</strong>：查看所有分支，有*字符的分支为当前分支</p>\n<p>-v：查看每一分支的最后一次提交</p>\n<p>–merged：列出合并到当前分支的分支</p>\n<p>–no-merged：列出未合并到当前分支的分支</p>\n<p>-d &lt;分支名&gt;：删除分支，未合并的分支需要-D强制删除</p>\n</li>\n<li><p>在指定的提交节点上创建分支：</p>\n<p>git branch <new_branch> &lt;commitHash&gt;</p>\n</li>\n<li><p>查看各分支当前所指的对象：</p>\n<p>git log –oneline –decorate</p>\n</li>\n<li><p>提交历史、各个分支的指向以及项目的分支分叉情况：</p>\n<p><strong>git log –oneline –decorate –graph</strong></p>\n</li>\n</ul>\n<h3 id=\"分支合并\"><a href=\"#分支合并\" class=\"headerlink\" title=\"分支合并\"></a>分支合并</h3><p>**git merge &lt;分支名&gt;**：将&lt;分支名&gt;合并到当前分支。</p>\n<ol>\n<li><p>直接后继合并</p>\n<p>C4是C2的直接后继</p>\n<p><img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804194944167.png\" alt=\"image-20210804194944167\"></p>\n<p>将指定的提交应用于当前分支：<strong>git cherry-pick &lt;commitHash&gt;</strong></p>\n</li>\n<li><p>非直接后继的合并</p>\n<p>Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的公共祖先（C2），做<strong>三方合并</strong>。结果得到一个新的快照并且自动创建一个新的提交指向它。</p>\n<p>这个被称作一次<strong>合并提交</strong>，它的特别之处在于他有<strong>不止一个父提交</strong>。</p>\n<img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804195235101.png\" alt=\"image-20210804195235101\" style=\"zoom:67%;\" /></li>\n<li><p>合并冲突</p>\n<p>在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，在合并它们的时候就会产生<strong>合并冲突。</strong></p>\n<p>合并冲突的解决：</p>\n<ol>\n<li><p><strong>git status</strong> 查看那些因包含合并冲突而处于未合并（unmerged）状态的文件。</p>\n</li>\n<li><p>Git在有冲突的文件中加入标准的冲突解决标记，打开这些包含冲突的文件<strong>手动解决冲突</strong>或者<strong>使用工具解决冲突：git mergetool</strong>。</p>\n<img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804195707129.png\" alt=\"image-20210804195707129\" style=\"zoom:67%;\" /></li>\n<li><p><strong>git add</strong> 命令来将其标记为冲突已解决。</p>\n</li>\n<li><p><strong>git commit</strong> 来完成合并提交。</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"四、远程仓库\"><a href=\"#四、远程仓库\" class=\"headerlink\" title=\"四、远程仓库\"></a>四、远程仓库</h2><p><strong>远程仓库：不仅表示仓库在网络或互联网上的其它位置，而只是表示它在别处。</strong></p>\n<h3 id=\"远程分支\"><a href=\"#远程分支\" class=\"headerlink\" title=\"远程分支\"></a>远程分支</h3><p><strong>远程分支</strong>：对远程仓库的引用（指针），包括分支、标签等。</p>\n<p><strong>远程跟踪分支</strong>（&lt;remote&gt;/&lt;branch&gt;）：远程分支状态的引用，比如origin/master。</p>\n<ul>\n<li><p>最后一次与远程仓库 origin 通信时分支的状态</p>\n</li>\n<li><p>无法在本地移动的，需要通过git fetch或者git pull命令才能移动。</p>\n</li>\n</ul>\n<p><strong>跟踪分支</strong>：在远程跟踪分支上建立的分支。</p>\n<p>作用：在跟踪分支上执行git pull，Git能自动识别去何服务器上加载，合并到何分支。</p>\n<ul>\n<li><p>创建跟踪分支：</p>\n<ul>\n<li><p>自定义跟踪分支名：<strong>git checkout -b &lt;branch&gt; &lt;remote&gt;/&lt;branch&gt;</strong></p>\n</li>\n<li><p>与远程分支同名：<strong>git checkout –track &lt;remote&gt;/&lt;branch&gt;</strong></p>\n</li>\n</ul>\n</li>\n<li><p>设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支：</p>\n<p>git branch -u &lt;remote&gt;/&lt;branch&gt;</p>\n</li>\n</ul>\n<blockquote>\n<p>git clone自动生成：远程跟踪分支origin/master分支和跟踪分支master分支。</p>\n</blockquote>\n<img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804200722263.png\" alt=\"image-20210804200722263\" style=\"zoom:50%;\" />\n\n\n\n<p><strong>远程分支其他命令：</strong></p>\n<ul>\n<li><p>查看远程分支：git ls-remote &lt;remote&gt;</p>\n</li>\n<li><p>查看远程分支的更多信息：git remote show &lt;remote&gt;</p>\n</li>\n<li><p>查看本地分支是领先还是落后，ahead本地分支领先，behind落后：</p>\n<p>git fetch –all; git branch -vv</p>\n</li>\n<li><p>删除远程分支：git push &lt;remote&gt; –delete &lt;branch&gt;</p>\n</li>\n</ul>\n<h3 id=\"克隆、拉取和推送命令\"><a href=\"#克隆、拉取和推送命令\" class=\"headerlink\" title=\"克隆、拉取和推送命令\"></a>克隆、拉取和推送命令</h3><p><img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804201748390.png\" alt=\"image-20210804201748390\"></p>\n<ul>\n<li><p>**git clone &lt;url&gt;**：添加远程仓库。</p>\n</li>\n<li><p><strong>git fetch &lt;remote&gt;<strong>：更新远程跟踪分支，会移动</strong>远程跟踪分支。</strong></p>\n<p>抓取克隆（或上一次抓取）后新推送的所有工作，但并不会自动合并或修改当前的工作。</p>\n</li>\n<li><p><strong>git pull</strong>：从最初克隆的服务器上<strong>抓取</strong>数据并自动尝试<strong>合并</strong>到当前所在的分支，相当于git fetch和git merge两个命令。</p>\n<p>在跟踪分支上执行git pull，Git能自动识别去何服务器上加载，合并到何分支。</p>\n</li>\n<li><p><strong>git push &lt;remote&gt; &lt;本地分支&gt;:&lt;远程分支&gt;</strong> <strong>：</strong>推送本地分支到远程仓库的分支上，必须先抓取并合并入本地后才能推送。</p>\n</li>\n</ul>\n<p>比如：</p>\n<img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804202320753.png\" alt=\"image-20210804202320753\" style=\"zoom:50%;\" />\n\n<p>执行git fetch origin后：</p>\n<ol>\n<li><p>origin/master分支移动</p>\n</li>\n<li><p>抓取克隆（或上一次抓取）后新推送的所有工作</p>\n</li>\n</ol>\n<img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804202331841.png\" alt=\"image-20210804202331841\" style=\"zoom:50%;\" />\n\n\n\n<h3 id=\"远程仓库其他命令\"><a href=\"#远程仓库其他命令\" class=\"headerlink\" title=\"远程仓库其他命令\"></a>远程仓库其他命令</h3><ul>\n<li><p>在克隆的仓库中<strong>添加新的远程仓库</strong>：</p>\n<p>git remote add &lt;shortname&gt; &lt;url | path&gt;</p>\n</li>\n<li><p>查看远程仓库，clone的远程仓库名默认是origin：</p>\n<p>git remote</p>\n<p>​    -v：显示仓库对应的url</p>\n</li>\n<li><p>查看远程仓库信息，跟踪分支信息，当前所处分支等：</p>\n<p>git remote show &lt;remote&gt; </p>\n</li>\n<li><p>修改一个远程仓库的简写名：git remote rename</p>\n</li>\n<li><p>移除远程仓库：git remote remove 或 git remote rm</p>\n</li>\n</ul>\n<h3 id=\"远程仓库案例\"><a href=\"#远程仓库案例\" class=\"headerlink\" title=\"远程仓库案例\"></a>远程仓库案例</h3><ol>\n<li><p>合并两个有关联的远程仓库</p>\n<ul>\n<li><p>添加远程仓库：git remote add &lt;shortname&gt; &lt;url | path&gt;</p>\n</li>\n<li><p>拉取远程仓库的代码：git fetch &lt;仓库名称&gt;</p>\n</li>\n</ul>\n<p>将远程仓库teamone添加到本地仓库：</p>\n<img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804205157287.png\" alt=\"image-20210804205157287\" style=\"zoom:50%;\" />\n\n<p>合并后：</p>\n<img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804205214864.png\" alt=\"image-20210804205214864\" style=\"zoom:50%;\" /></li>\n<li><p>合并两个相互独立的仓库</p>\n<p>示例：将本地的gitdemo1仓库和gitdemo2仓库合并。</p>\n<ol>\n<li><p>将gitdemo2作为远程仓库添加到gitdemo1中，别名为other：</p>\n<p>git remote add other /Users/didi/Documents/gitdemo2</p>\n</li>\n<li><p>拉取other到gitdemo1仓库：</p>\n<p>git fetch other</p>\n</li>\n<li><p>创建跟踪分支two：</p>\n<p>git checkout -b two other/master</p>\n</li>\n<li><p>切换到master分支：</p>\n<p>git checkout master</p>\n</li>\n<li><p>合并分支：</p>\n<p>git merge two <strong>–allow-unrelated-histories</strong></p>\n</li>\n<li><p>解决合并冲突</p>\n</li>\n<li><p>查看提交历史、各个分支的指向以及项目的分支分叉情况：</p>\n<p>git log –oneline –decorate –graph</p>\n</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"五、标签\"><a href=\"#五、标签\" class=\"headerlink\" title=\"五、标签\"></a>五、标签</h2><p><strong>标签</strong>可以理解为<strong>版本别名。</strong>如果你达到一个重要的阶段，并希望永远记住那个特别的提交快照，可以在快照上打标签。</p>\n<p>Git 支持两种标签：轻量标签（lightweight）与附注标签（annotated）。</p>\n<ul>\n<li><p>轻量标签：某个特定提交的引用。</p>\n</li>\n<li><p>附注标签：存储在 Git 数据库中的一个完整对象，可被校验，其中包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息。</p>\n</li>\n</ul>\n<p>标签相关命令：</p>\n<ul>\n<li><p>列出所有标签：git tag</p>\n<p>​      -l &lt;pattern&gt;：按特定模式查找标签</p>\n</li>\n<li><p>创建附注标签：git tag -a &lt;tagname&gt; -m “my version 1.4”</p>\n</li>\n<li><p>创建轻量标签：git tag &lt;tagname&gt;</p>\n</li>\n<li><p>对过去的提交打标签：git tag -a &lt;tagname&gt; &lt;commitHash&gt;</p>\n</li>\n<li><p><strong>查看标签信息和与之对应的提交信息：git show &lt;tagname&gt;</strong></p>\n</li>\n<li><p>标签需要显式推送： git push origin &lt;tagname&gt;</p>\n</li>\n<li><p>推送所有不在远程仓库服务器上的标签：git push origin –tags</p>\n</li>\n<li><p>删除掉你本地仓库上的标签：git tag -d &lt;tagname&gt;</p>\n</li>\n<li><p>删除远程标签：git push origin –delete &lt;tagname&gt;</p>\n</li>\n</ul>\n<h2 id=\"六、Git常用命令\"><a href=\"#六、Git常用命令\" class=\"headerlink\" title=\"六、Git常用命令\"></a>六、Git常用命令</h2><h3 id=\"1-撤销\"><a href=\"#1-撤销\" class=\"headerlink\" title=\"1. 撤销\"></a>1. 撤销</h3><p>Git中所有已提交的几乎都可以恢复，但是未提交的可能再也找不到。</p>\n<ol>\n<li><p>上一次提交中漏了几个文件或者提交信息写错</p>\n<p><strong>git</strong> <strong>commit</strong> <strong>–amend</strong>：将暂存区中的文件提交，<strong>覆盖</strong>上一次提交</p>\n<p>例如：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git commit -m <span class=\"string\">&#x27;initial commit’ </span></span><br><span class=\"line\"><span class=\"string\">$ git add forgotten_file </span></span><br><span class=\"line\"><span class=\"string\">$ git commit --amend -m “修改后的提交信息”</span></span><br></pre></td></tr></table></figure></li>\n<li><p>已经修改了两个文件并且想要将它们作为两次独立的修改提交， 但是却意外地输入 <code>git add .</code> 暂存了它们两个。</p>\n<p>git reset HEAD &lt;file&gt;：取消暂存文件</p>\n</li>\n<li><p>撤销对文件的修改</p>\n<ul>\n<li><p>还未暂存的文件使用：</p>\n<p><strong>git</strong> <strong>checkout</strong> <strong>– &lt;file&gt;</strong></p>\n<p><strong>将工作区文件替换为暂存区的文件</strong></p>\n</li>\n<li><p>已经暂存的文件使用：</p>\n<p><strong>git</strong> <strong>checkout</strong> <strong>HEAD &lt;file&gt;</strong></p>\n<p><strong>将暂存取和工作区的文件替换为HEAD指针指向的提交节点的文件</strong></p>\n</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"reset\"><a href=\"#reset\" class=\"headerlink\" title=\"reset\"></a>reset</h4><p>git reset HEAD~n：移动HEAD和HEAD指向的分支到前n个提交节点。</p>\n<ul>\n<li>git reset –soft HEAD~</li>\n<li>git reset [–mixed] HEAD~：将暂存区替换为HEAD前一个节点</li>\n<li>git reset –hard HEAD~：将暂存区和工作区都替换为HEAD前一个节点</li>\n</ul>\n<p><img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804204300984.png\" alt=\"image-20210804204300984\"></p>\n<p><strong>带路径：</strong>不移动HEAD指针</p>\n<ul>\n<li><p>**git reset &lt;file&gt;**：取消暂存文件</p>\n</li>\n<li><p>**git reset &lt;commitHash&gt; &lt;file&gt;**：从指定节点中拉取文件来替换暂存区中的文件。</p>\n</li>\n</ul>\n<p>git checkout &lt;branch&gt;</p>\n<ul>\n<li><p>存在已修改文件时切换时会有提示</p>\n</li>\n<li><p>只移动HEAD自身</p>\n</li>\n</ul>\n<p><a href=\"https://blog.csdn.net/yxlshk/article/details/79944535\">reset和revert的区别</a>：</p>\n<p><img src=\"https://lexie-1306706019.cos.ap-shanghai.myqcloud.com/assets/image-20210804204632156.png\" alt=\"image-20210804204632156\"></p>\n<h3 id=\"2-查看提交历史\"><a href=\"#2-查看提交历史\" class=\"headerlink\" title=\"2. 查看提交历史\"></a>2. 查看提交历史</h3><p><strong>git log</strong>：显示提交记录</p>\n<p>​    -p 或 –patch ：显示每次提交所引入的差异</p>\n<p>​    -数字：显示最近的n次提交</p>\n<p>​    –stat：显示每次提交的简略统计信息</p>\n<p>​    –pretty=online：每个提交在一行显示</p>\n<p>​    –pretty=format:“格式”：定制记录的显示格式</p>\n<p>​    –since=&lt;date&gt;</p>\n<p>​    –author=&lt;name&gt;：显示指定作者的提交</p>\n<p>​    –grep=&lt;key&gt;：搜索提交中的关键字</p>\n<p>​    – &lt;path&gt;：显示指定文件目录的提交历史</p>\n<ul>\n<li><p>查看各分支当前所指的对象：</p>\n<p>git log –oneline –decorate</p>\n</li>\n<li><p>提交历史、各个分支的指向以及项目的分支分叉情况：</p>\n<p><strong>git log –oneline –decorate –graph</strong></p>\n</li>\n</ul>\n<h2 id=\"七、总结\"><a href=\"#七、总结\" class=\"headerlink\" title=\"七、总结\"></a>七、总结</h2><ol>\n<li><p><strong>直接记录快照，而非差异比较</strong></p>\n<p>本地存储一个对象数据库，每当你提交更新或保存项目状态时，对当时的全部文件创建一个快照并保存这个快照的索引。 为了效率，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 </p>\n</li>\n<li><p><strong>近乎所有操作都是本地执行</strong></p>\n<p>在本地磁盘上就有项目的完整历史，所以大部分操作看起来瞬间完成。</p>\n<p>Git 处理分支的方式非常轻量，创建新分支只是创建一个引用，几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。</p>\n</li>\n<li><p><strong>Git</strong> <strong>保证完整性</strong></p>\n<p>Git 中所有的数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。</p>\n</li>\n</ol>\n<h2 id=\"八、遇到的问题\"><a href=\"#八、遇到的问题\" class=\"headerlink\" title=\"八、遇到的问题\"></a>八、遇到的问题</h2><ol>\n<li><p>问题运行git pull报错：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fatal: unable to access &#x27;https://github.com/wangyywyy/wangyywyy.github.io.git/&#x27;: LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443</span><br></pre></td></tr></table></figure>\n\n<p>原因：git config –global –list没有配置用户名邮箱</p>\n<p>解决：配置以下信息：</p>\n<p>git config –global user.name “wangyywyy”</p>\n<p>git config –global user.email “<a href=\"mailto:&#119;&#97;&#x6e;&#103;&#121;&#121;&#120;&#x74;&#121;&#106;&#64;&#x31;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;\">&#119;&#97;&#x6e;&#103;&#121;&#121;&#120;&#x74;&#121;&#106;&#64;&#x31;&#54;&#51;&#46;&#x63;&#x6f;&#x6d;</a>“</p>\n</li>\n<li><p>git push origin master报错：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">error: src refspec master does not match any</span><br><span class=\"line\">error: failed to push some refs to &#x27;https://github.com/wangyywyy/wangyywyy.github.io.git&#x27;</span><br></pre></td></tr></table></figure></li>\n</ol>\n","categories":[],"tags":[]}